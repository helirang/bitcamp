#include "turboc.h"

#define col 50
#define row 25


typedef struct _UserMove // 유저 이동에 관여하는 변수 모음
{
    int x, y, PointL, PointR;
    int starCount;
    int end;
    int userJumpH;
}Usermove;

typedef struct _Jump // 유저 점프에 관여하는 변수 모음
{
    int jump, jumpUpCount;
}Jump;

typedef struct _Bullet // 총알에 관여하는 변수 모음
{
    int Bx, By, bulletCount, bPointL, bPointR;
}Bullet;

typedef struct _Time // 각 행동들이 반복되는 시간을 제한하는 변수 모음 == 0.2초에 1번과 같이
{
    clock_t NowUerTime, NowJump, BulletTime;
    clock_t TimeFilter1, TimeFilter2, TimeFilter3;
}Time;

// 벽은 -1, 캐릭터는 5, 총알은 3, 별은 10, 아이템 상자는 7

void userTypeChange(Usermove* user1)
{
    gotoxy(user1->x, user1->y);

    printf("◈");
}

void BoxChange(Usermove* user1, int Map[][col], int coll, int roww)
{
    Map[user1->y - 1][user1->x / 2 + user1->x % 2] = -1;
    gotoxy(user1->x, user1->y - 1);
    printf("■");
    Map[user1->y - 2][user1->x / 2 + user1->x % 2] = 10;
    gotoxy(user1->x, user1->y - 2);
    printf("★");
}

void CopyArray(int Map[][col], int coll, int roww, int stage, int Mapdummy[][col], int colldummy, int rowwdummy)
{
    for (int rowCopy = 0; rowCopy < row + 1; rowCopy++)
    {
        for (int colCopy = 0; colCopy < col; colCopy++)
        {
            Map[rowCopy][colCopy] = Mapdummy[rowCopy][colCopy];
        }
    }
}


void CopyArrayMap(int Map[][col], int coll, int roww, int stage)
{
    int Map2[row + 1][col] = {
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,10,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,-1},
{-1,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,-1,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1} };

    int Map1[row + 1][col] = {
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,10,0,0,0,10,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,-1,-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,-1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1} };

    int Map3[row + 1][col] = { { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,-1,0,0,-1 },
    { -1,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1 },
    { -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,10,-1 },
    { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 }
    };

    int Map0[row + 1][col] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1},
{-1,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,10,0,0,0,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1},
{-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,-1},
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1} };

    int colMap = sizeof(Map0[0]) / sizeof(int);
    int rowMap = sizeof(Map0) / sizeof(Map0[0]);

    switch (stage)
    {
    case 0:
        CopyArray(Map, coll, roww, stage, Map0, colMap, rowMap);
        break;

    case 1:
        CopyArray(Map, coll, roww, stage, Map1, colMap, rowMap);
        break;

    case 2:
        CopyArray(Map, coll, roww, stage, Map2, colMap, rowMap);
        break;

    case 3:
        CopyArray(Map, coll, roww, stage, Map3, colMap, rowMap);
        break;

    default:
        break;
    }


}

void readyMap(int Map[][col], int coll, int roww, int stage, Usermove* starCount)
{
    int mapDraw = 0;
    switch (stage)
    {
    case 0:
        CopyArrayMap(Map, coll, roww, stage);
        starCount->x = 2;
        starCount->y = 24;
        Map[24][1] = 5;
        starCount->starCount = 2;
        starCount->userJumpH = 4;
        break;

    case 1:
        CopyArrayMap(Map, coll, roww, stage);
        starCount->x = 2;
        starCount->y = 24;
        Map[24][1] = 5;
        starCount->starCount = 5;
        starCount->userJumpH = 7;
        break;

    case 2:
        CopyArrayMap(Map, coll, roww, stage);
        starCount->x = 2;
        starCount->y = 24;
        Map[24][1] = 5;
        starCount->starCount = 5;
        starCount->userJumpH = 4;
        break;

    case 3:
        CopyArrayMap(Map, coll, roww, stage);
        starCount->x = 2;
        starCount->y = 24;
        Map[24][1] = 5;
        starCount->starCount = 1;
        starCount->userJumpH = 4;
        break;

    default:
        break;
    }

    for (int rowW = 0; rowW < row + 1; rowW++)
    {
        for (int colW = 0; colW < col; colW++)
        {
            if (Map[rowW][colW] == -1)
            {
                printf("■");
            }
            else if (Map[rowW][colW] == 5)
            {
                printf("◈");
            }
            else if (Map[rowW][colW] == 10)
            {
                printf("★");
            }
            else if (Map[rowW][colW] == 8)
            {
                printf("※");
            }
            else
            {
                printf("  ");
            }
        }
        printf("\n");
    }
}

void usermove(Usermove* user1, Jump* jump1, Bullet* bullet1, int Map[][col], int coll, int roww) // 유저 이동과 점프키 그리고 총알 발사를 키보드로 입력 받는 함수. D누르면 총알 발사 등
{
    if (GetAsyncKeyState(0x53) & 0x8000) {
        if (jump1->jump == 0) // 점프는 0일 때만 작동 // 점프가 0이 아니면 허공에서 계속 점프가 가능한 오류가 생김
        {
            jump1->jumpUpCount = 2; // Main 함수에서 jumpUpCount = 2이면 userjumpUp 함수가 실행 됨.
        }
    }

    if (GetAsyncKeyState(VK_LEFT) & 0x8000) { //왼쪽 // x-2는 왼쪽
        if (user1->x - 2 == 0) // x값 -2가 0이면 Main에 전달되는 Point(방향 변수)를 반대로 하게 하는 if문
        {
            user1->PointR = 1; // 이렇게 해야 벽 왼쪽 끝에 갔을 때, 오른쪽으로 총알 발사 가능
            user1->PointL = 0;
        }
        else if (Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == 10) // 유저의 왼쪽( x-1)이 벽(-1)이면 이번 반복에서는 아무 행동도 안함.
        {
            user1->starCount -= 1;

            gotoxy(user1->x, user1->y); // 유저 현재 위치에서
            printf("  "); // 삭제 

            Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map 2차 배열에 현재 유저 위치 0으로 바꾸기

            user1->x -= 2; // x 변수에서 2를 빼기
            user1->PointL = 1; // 방향 왼쪽 변수에 1을 대입
            user1->PointR = 0; // 방향 오른쪽 변수는 0으로 만든다( 왼쪽이니까 )
        }
        else if (Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == 8)
        {
            user1->end = 1;
        }
        else if (Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == -1) // 유저의 왼쪽( x-1)이 벽(-1)이면 이번 반복에서는 아무 행동도 안함.
        {
        }
        else
        {
            gotoxy(user1->x, user1->y); // 유저 현재 위치에서
            printf("  "); // 삭제 

            Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map 2차 배열에 현재 유저 위치 0으로 바꾸기

            user1->x -= 2; // x 변수에서 2를 빼기
            user1->PointL = 1; // 방향 왼쪽 변수에 1을 대입
            user1->PointR = 0; // 방향 오른쪽 변수는 0으로 만든다( 왼쪽이니까 )
        }
    }
    if (GetAsyncKeyState(VK_RIGHT) & 0x8000) { // 오른쪽 // x+2는 오른쪽
        if (user1->x + 2 == col * 2 - 2) // x값 +2가 0이면 Main에 전달되는 Point(방향 변수)를 반대로 하게 하는 if문
        {
            user1->PointR = 0;
            user1->PointL = 1; // 이렇게 해야 벽 오른쪽 끝에 갔을 때, 오른쪽으로 총알 발사 가능
        }
        else if (Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == 10) // 유저의 왼쪽( x-1)이 벽(-1)이면 이번 반복에서는 아무 행동도 안함.
        {
            user1->starCount -= 1;

            gotoxy(user1->x, user1->y);
            printf("  ");

            Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map 2차 배열에 현재 유저 위치 0으로 바꾸기

            user1->x += 2; // x 변수에서 2를 더하기
            user1->PointL = 0; // 방향 왼쪽 변수에 0을 대입
            user1->PointR = 1; // 방향 오른쪽 변수에 1을 대입
        }
        else if (Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == 8)
        {
            user1->end = 1;
        }
        else if (Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == -1 || Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == 7) // 유저의 오른쪽( x+1)이 벽(-1)이면 이번 반복에서는 아무 행동도 안함.
        {
        }
        else
        {
            gotoxy(user1->x, user1->y);
            printf("  ");

            Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map 2차 배열에 현재 유저 위치 0으로 바꾸기

            user1->x += 2; // x 변수에서 2를 더하기
            user1->PointL = 0; // 방향 왼쪽 변수에 0을 대입
            user1->PointR = 1; // 방향 오른쪽 변수에 1을 대입
        }
    }
    if (GetAsyncKeyState(0x44) & 0x8000) // 총알 
    {
        if (bullet1->bulletCount == 0) // bulletCount는 현재 나와있는 총알을 세는 변수, 총알이 0개일 때 진행되는 if문
        {
            if (user1->PointL == 1) // userMove함수에서 받아온 pointL(왼쪽)이 1이면 진행
            {
                if (user1->x - 3 == 0 || user1->x - 2 == 0 || Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == -1 || Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == 7 || Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == 8 || Map[user1->y][user1->x / 2 + user1->x % 2 - 1] == 10) // 유저 왼쪽이 벽이면
                { // 행동 x
                }
                else
                {
                    gotoxy(user1->x - 2, user1->y); // 현재 유저 위치에서 왼쪽에
                    printf("◀"); // 총알 생성
                    bullet1->Bx = user1->x - 2; // 총알 좌우 위치를 기억하는 변수 Bx에, 만들어진 총알에 위치 전달
                    bullet1->By = user1->y; // 총알 상하 위치를 기억하는 변수 Bx에, 만들어진 총알에 위치 전달

                    Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 3; // 만들어진 총알 위치를 Map에 전달
                    bullet1->bulletCount = 1; // 총알 1개가 만들어졌으므로 bulletCount 변수를 1로 만듬.
                    bullet1->bPointL = 1; // 왼쪽으로 발사된 총알이므로 bPointL = 1로 만듬
                }
            }
            else if (user1->PointR == 1) // userMove함수에서 받아온 pointR(오른쪽)이 1이면 진행
            {
                if (user1->x + 2 == col * 2 - 3 || user1->x + 2 == col * 2 - 2 || Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == -1 || Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == 7 || Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == 8 || Map[user1->y][user1->x / 2 + user1->x % 2 + 1] == 10) // 유저의 오른쪽이 벽이면 
                {// 행동 x
                }
                else
                {
                    gotoxy(user1->x + 2, user1->y); // 현재 유저 위치에서 오른쪽에
                    printf("▶"); // 총알 생성
                    bullet1->Bx = user1->x + 2; // 총알 좌우 위치를 기억하는 변수 Bx에, 만들어진 총알에 위치 전달
                    bullet1->By = user1->y; // 총알 상하 위치를 기억하는 변수 Bx에, 만들어진 총알에 위치 전달

                    Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 3; // 만들어진 총알 위치를 Map에 전달
                    bullet1->bulletCount = 1;  // 총알 1개가 만들어졌으므로 bulletCount 변수를 1로 만듬.
                    bullet1->bPointR = 1; // 오른쪽으로 발사된 총알이므로 bPointR = 1로 만듬
                }
            }
        }
    }
    gotoxy(user1->x, user1->y); // 현재 유저(x,y) 위치로 이동
    Map[user1->y][user1->x / 2 + user1->x % 2] = 5; // 이동한 유저 위치를 Map에 전달
    userTypeChange(user1);
}

void userjumpUp(Usermove* user1, Jump* jump1, int Map[][col], int coll, int roww) // 점프하면 올라가는 함수
{
    if (Map[user1->y - 1][user1->x / 2 + user1->x % 2] == -1) // 유저 바로 위가 벽돌(-1)일 시 
    {
        jump1->jumpUpCount = 1; // jumpUpCount 1은 Main에서 userjumpDown함수를 움직이게 하는 값.
    }
    else if (Map[user1->y - 1][user1->x / 2 + user1->x % 2] == 10)
    {
        jump1->jumpUpCount = 1;
        user1->starCount -= 1;
        gotoxy(user1->x, user1->y); // 현재 유저 위치에서
        printf("  "); // 유저 삭제

        Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map에 현재 유저 위치를 0으로 만듬

        user1->y -= 1; // 1칸 올라간다.

        Map[user1->y][user1->x / 2 + user1->x % 2] = 5; // Map에 변경된 x값을 이용해, 현재 유저 위치를 5로 표시함.

        gotoxy(user1->x, user1->y); // 현재 유저 위치에
        printf("◈"); // 유저 생성

        ++(jump1->jump); // 점프 증가.
    }
    else if (Map[user1->y - 1][user1->x / 2 + user1->x % 2] == 7) // 아이템 만들기 
    {
        jump1->jumpUpCount = 1;

        BoxChange(user1, Map, coll, roww);
    }
    else if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == 8)
    {
        user1->end = 1;
    }
    else
    {
        gotoxy(user1->x, user1->y); // 현재 유저 위치에서
        printf("  "); // 유저 삭제

        Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map에 현재 유저 위치를 0으로 만듬

        user1->y -= 1; // 1칸 올라간다.

        Map[user1->y][user1->x / 2 + user1->x % 2] = 5; // Map에 변경된 x값을 이용해, 현재 유저 위치를 5로 표시함.

        gotoxy(user1->x, user1->y); // 현재 유저 위치에
        printf("◈"); // 유저 생성

        ++(jump1->jump); // 점프 증가.
    }

    if (jump1->jump == user1->userJumpH - 1) delay(20);

    if (jump1->jump == user1->userJumpH) // 관리자가 설정한 최고 점프 높이( 전역변수 - JumpH )에 도달하면
    {
        jump1->jumpUpCount = 1; // Main에서 점프 동작에 관여하는 jumpUpCount를 1로 만듬. jumpUpCount == 1은 userjumpDown을 실행
    }
};

void userjumpDown(Usermove* user1, Jump* jump1, int Map[][col], int coll, int roww)// 점프하면 내려오는 역할을 하는 함수
{
    if (jump1->jump == user1->userJumpH) delay(30);// JumpH는 5. 점프 위치가 최대이면 딜레이 20

    if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == 10)
    {
        user1->starCount -= 1;
    }

    if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == -1)   // 제한 넣기
    {
        jump1->jump = 0; //  Map에 저장된, 현재 위치에서 바로 아래(y+1) 위치가 벽(-1)일 시, jump 변수를 0으로 한다.
    }
    else if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == 0) // //  Map에 저장된, 현재 위치에서 바로 아래(y+1) 위치가 허공(0)일 시,
    {
        gotoxy(user1->x, user1->y); // 현재 위치에
        printf("  "); // "  "출력

        Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map에 현재 위치 0으로 변경

        user1->y += 1; // 1칸 내려온다

        Map[user1->y][user1->x / 2 + user1->x % 2] = 5; // 변경된 y값을 적용한, 유저의 현재 위치 갱신

        gotoxy(user1->x, user1->y); // 변경된 현재 위치에
        userTypeChange(user1);

        jump1->jump = 1;
        jump1->jumpUpCount = 1; // 점프 카운트를 1로 만들어 Main에서 다시 userjumpDown함수가 시작하게 한다.
    }
    else if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == 8)
    {
        user1->end = 1;
    }
    else // 위 두 조건문에 해당하지 않는다면
    {
        gotoxy(user1->x, user1->y);// 현재 위치에
        printf("  "); // "  "출력

        Map[user1->y][user1->x / 2 + user1->x % 2] = 0; // Map에 현재 위치 0으로 변경

        user1->y += 1; // 1칸 내려온다 

        Map[user1->y][user1->x / 2 + user1->x % 2] = 5; // 변경된 y값을 적용한, 유저의 현재 위치 갱신

        gotoxy(user1->x, user1->y);  // 변경된 현재 위치에
        userTypeChange(user1);

        (jump1->jump)--; // 점프 값 감소.
    }
    if (jump1->jump == user1->userJumpH - 1) delay(20);
    if (jump1->jump == 0) jump1->jumpUpCount = 0; delay(20); // jump가 0이면 jumpUpCount를 0으로 변경해서 함수 userjumpUP과 userjumpDown이 실행되지 않게 한다.
}

void userBlankDown(Usermove* user1, Jump* jump1, int Map[][col], int coll, int roww) // 아래가 빈공간이라면
{
    if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == 10)
    {
        jump1->jumpUpCount = 1; // jumpUpCount를 1로 바꿔서 userjumpDown함수가 실행되게 한다.
    }
    else if (Map[user1->y + 1][user1->x / 2 + user1->x % 2] == 0) // Map에 저장된 현재 위치 바로 아래가 빈공간(0)이라면 
    {
        jump1->jumpUpCount = 1;
    }
}

void bulletMove(Bullet* bullet1, int Map[][col], int coll, int roww) // 총알 움직임
{
    int BulletSpeed = 1; // 총알 속도
    if (bullet1->bulletCount == 1) // 총알 카운트가 1일 떄
    {
        if (bullet1->bPointL == 1) // 유저가 왼쪽을 바라볼 때, 만들어진 총알이면
        {

            if (bullet1->Bx - 2 == 0 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 - 1] == -1 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 - 1] == 10 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 - 1] == 8 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 - 1] == 7) // 총알 x위치에서 -2한 값이 0이거나( || ) Map에 저장된 총알 위치에서 x-1(왼쪽 한칸) 값이 벽 (-1)이면
            {
                gotoxy(bullet1->Bx, bullet1->By); // 현재 위치에
                printf("  "); // "  " 출력

                Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 0; // Map에 총알 현재 위치 0으로 갱신

                bullet1->Bx = 0, bullet1->By = 0; // 총알 좌표 0으로 
                bullet1->bPointL = 0; // 총알 방향 변수 bPointL를 0으로
                bullet1->bulletCount = 0; // 총알이 사라졌으니, bulletCount를 0으로
            }
            else
            {
                gotoxy(bullet1->Bx, bullet1->By);  // 현재 위치에
                printf("  ");// "  " 출력

                Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 0; // Map에 총알 현재 위치 0으로 갱신

                bullet1->Bx -= BulletSpeed;  // 총알의 x값을 왼쪽으로 BulletSpeed만큼 이동

                Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 3; // 변경된 총알의 위치를 Map에 갱신

                gotoxy(bullet1->Bx, bullet1->By); // 변경된 위치에
                printf("◀"); // 총알 출력
            }
        }
        if (bullet1->bPointR == 1) // 유저가 오른쪽을 바라볼 때, 만들어진 총알이면
        {

            if (bullet1->Bx + 2 == col * 2 - 2 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 + 1] == -1 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 + 1] == 7 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 + 1] == 8 || Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2 + 1] == 10) // 총알 x위치에서 + 2한 값이 0이거나(|| ) Map에 저장된 총알 위치에서 x + 1(오른쪽 한칸) 값이 벽(-1)이면
            {
                gotoxy(bullet1->Bx, bullet1->By); // 현재 위치에
                printf("  "); // "  " 출력

                Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 0; // Map에 총알 현재 위치 0으로 갱신

                bullet1->Bx = 0, bullet1->By = 0; // 총알 좌표 0으로 
                bullet1->bPointR = 0; // 총알 방향 변수 bPointR를 0으로
                bullet1->bulletCount = 0; // 총알이 사라졌으니, bulletCount를 0으로

            }
            else
            {
                gotoxy(bullet1->Bx, bullet1->By); // 현재 위치에
                printf("  "); // "  " 출력
                Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 0; // Map에 총알 현재 위치 0으로 갱신

                bullet1->Bx += BulletSpeed; // 총알의 x값을 오른쪽으로 BulletSpeed만큼 이동

                Map[bullet1->By][bullet1->Bx / 2 + bullet1->Bx % 2] = 3; // 변경된 총알의 위치를 Map에 갱신
                gotoxy(bullet1->Bx, bullet1->By); // 변경된 위치에
                printf("▶"); // 총알 출력
            }
        }
    }
}

///////////////////////////////////////////////////////////////////

void main()
{

    Usermove user1; // 유저 이동에 관여하는 변수 모음
    Jump jump1; // 유저 점프에 관여하는 변수 모음
    Bullet bullet1; // 총알에 관여하는 변수 모음
    Time time1; // 행동 시간을 제어하는데 관여하는 변수 모음

    setcursortype(NOCURSOR);

    ///////////////////////////////// 구조체 모음

    user1.y = 0, user1.x = 0, user1.PointL = 0, user1.PointR = 0, user1.starCount = 0, user1.userJumpH = 4, user1.end = 0;
    bullet1.Bx = 0, bullet1.By = 0, bullet1.bulletCount = 0, bullet1.bPointL = 0, bullet1.bPointR = 0;
    jump1.jump = 0, jump1.jumpUpCount = 0;
    time1.NowUerTime = 0, time1.NowJump = 0, time1.BulletTime = 0, time1.TimeFilter1 = 80, time1.TimeFilter2 = 32, time1.TimeFilter3 = 25;

    ///////////////////////////////// Main 지역 변수 모음

    int Map[row + 1][col];
    int colMap = sizeof(Map[0]) / sizeof(int);
    int rowMap = sizeof(Map) / sizeof(Map[0]);
    int itemReset = 0;
    int stage = 3;
    int playtimeS = 0;
    int PlayTimeA[10] = { 0 };

    int totalGameTime = 0;
    int GameStop = 0;

    /////////////////////////////////



    while (1)
    {


        readyMap(Map, colMap, rowMap, stage, &user1);

        while (1)
        {
            if (clock() - time1.NowUerTime >= time1.TimeFilter1) // 대충 0.1초마다 작동 // 이동제한, 프로그램 시작부터 지난 시간 - 저장된 시간 >= 0.1초보다 크면 작동.
            {
                usermove(&user1, &jump1, &bullet1, Map, colMap, rowMap); // 유저이동 함수
                time1.NowUerTime = clock(); // 유저이동함수를 이용한 시간 갱신
            }

            if (clock() - time1.NowJump >= time1.TimeFilter2) // 위와 같다. 대충 0.1초마다 작동
            {
                if (jump1.jumpUpCount == 2) // 점프 카운트가 2이면 점프 업 함수 실행
                {
                    userjumpUp(&user1, &jump1, Map, colMap, rowMap);
                }
                else if (jump1.jumpUpCount == 1)  // 점프 카운트가 1이면 점프 업 함수 실행
                {
                    userjumpDown(&user1, &jump1, Map, colMap, rowMap);
                }
                else if (jump1.jumpUpCount == 0) // 점프 카운트가 0이면  userBlankDown( 바닥이 허공인지 판단해서 아래로 떨구는 함수 ) 실행
                {
                    userBlankDown(&user1, &jump1, Map, colMap, rowMap);
                }
                time1.NowJump = clock(); // 점프 함수를 이용한 시간 갱신
            }

            if (clock() - time1.BulletTime >= time1.TimeFilter3)  // 위와 같다. 대충 0.025초마다 작동
            {
                if (bullet1.Bx != 0 && bullet1.By != 0) // 총알의 Bx위치가 0이 아니고, By위치가 0이 아니면 실행한다.
                {
                    bulletMove(&bullet1, Map, colMap, rowMap); // 총알 이동함수 실행
                }
                time1.BulletTime = clock(); // 총알 이동함수 사용 시간 갱신
            }

            if (GetAsyncKeyState(0x52) & 0x8000) /// F키를 누르면 게임을 종료한다.
            {
                GameStop = 1;
                break;
            }

            gotoxy(53 * 2 - 2, 0);
            printf(" 별 개수");
            gotoxy(53 * 2 - 2, 1);
            printf(" : %2d", user1.starCount);

            playtimeS = clock() / 1000;

            if (stage == 0)
            {

            }
            else
            {
                playtimeS = playtimeS - PlayTimeA[stage - 1];
            }

            gotoxy(53 * 2 - 2, 6);
            printf(" [Stage %2d]", stage + 1);

            if (playtimeS / 60 >= 1)
            {
                gotoxy(53 * 2 - 2, 3);
                printf(" Play Time");
                gotoxy(53 * 2 - 2, 4);
                printf(" : %2d분 %2d초", playtimeS / 60, playtimeS % 60);
            }
            else
            {
                gotoxy(53 * 2 - 2, 3);
                printf(" Play Time");
                gotoxy(53 * 2 - 2, 4);
                printf(" : %2d 초", playtimeS);
            }

            if (user1.starCount == 0)
            {
                gotoxy(user1.x, user1.y + 1);
                printf(" ※%d STAGE CLEAR※ ", stage + 1);
                delay(3000);

                playtimeS = clock() / 1000;
                PlayTimeA[stage] = playtimeS;
                stage += 1;
                if (stage < 3)
                {
                    clrscr();
                }

                break;
            }

            if (user1.end == 1)
            {
                break;
            }
        }

        if (GameStop == 1)
        {
            break;
        }

        if (stage == 4 || user1.end == 1)
        {
            int gameYN = 0;

            if (user1.end == 1)
            {
                gotoxy(0, 27);
                printf("Trap!!!!!!!!!!!!!");
            }
            gotoxy(0, 28);
            printf("다시 하시겠습니까? YES [1] / NO[else]");
            scanf_s("%d", &gameYN);

            if (gameYN == 1)
            {
                clrscr();
                stage = 0;
                user1.end = 0;
                //gameYN = 0;
            }
            else
            {
                for (int i = 0; i < 4; i++)
                {
                    gotoxy(51 * 2 - 2, 8 + i * 2);
                    printf("※%d STAGE CLEARTIME※", i + 1);
                    gotoxy(51 * 2 - 2, 9 + i * 2);
                    printf("%2d분 %2d초", PlayTimeA[i] / 60, PlayTimeA[i] % 60);
                    totalGameTime += PlayTimeA[i];
                }

                gotoxy(0, 30);
                if (totalGameTime / 60 > 1)
                {
                    printf(" GAME END \t 최종 클리어 시간 %d초", totalGameTime);
                }
                else
                {
                    printf(" GAME END \t 최종 클리어 시간 %d분 %d초", totalGameTime / 60, totalGameTime % 60);
                }
                break;
            }
        }
    }

    //////////////////////////// 맵 데이터 확인

    if (GameStop == 1)
    {
        int orion = 0;

        gotoxy(0, 27);

        for (int rowW = 0; rowW < row + 1; rowW++)
        {
            for (int colW = 0; colW < col; colW++)
            {
                orion = Map[rowW][colW];
                printf("%2d", orion);
            }
            printf("\n");
        }
    }
}